# Miyabi Prompting Guide
## miyabiの効率を最大化するための指示の出し方

このガイドは、miyabi (Autonomous Development Framework) を使用する際に、最も効率的な結果を得るための指示方法（プロンプティング）のベストプラクティスをまとめたものです。

---

## 📚 目次

1. [イントロダクション](#イントロダクション)
2. [タスクタイプ別ガイド](#タスクタイプ別ガイド)
3. [プロンプトテンプレート集](#プロンプトテンプレート集)
4. [実践チュートリアル](#実践チュートリアル)
5. [トラブルシューティング](#トラブルシューティング)
6. [アンチパターン](#アンチパターン)

---

## イントロダクション

### miyabiの特性理解

miyabiは以下の特性を持つ自律型開発フレームワークです：

- **6つの専門Agent**: Analyzer, Coordinator, Builder, Reviewer, Tester, Packager
- **品質基準**: 80点以上のスコアを要求
- **自動化**: Issue → Code → Test → PR の完全自動化
- **Claude Sonnet 4駆動**: 高度なAI推論による実装

### 効率的な指示の重要性

明確で具体的な指示は：
- ✅ 実装精度を向上させる（成功率 95%+ を維持）
- ✅ 品質スコアを高める（目標: 80点以上）
- ✅ 実行時間を短縮する（通常30-60秒）
- ✅ エスカレーションを減らす

---

## タスクタイプ別ガイド

### 1. fix-bug（バグ修正）

#### 推奨フォーマット

```markdown
## バグ内容
[バグの具体的な症状]

## 再現手順
1. [ステップ1]
2. [ステップ2]
3. [エラー発生]

## 期待される動作
[正しい動作の説明]

## 実際の動作
[現在のバグのある動作]

## 環境
- OS: [macOS/Linux/Windows]
- Node.js: [v20.x.x]
- Browser: [Chrome 120+]

## エラーログ
```
[エラーメッセージ]
```

## 提案される修正方針（任意）
[修正のヒント]
```

#### 実例

```markdown
## バグ内容
ユーザー登録時、メールアドレスのバリデーションが機能せず、
無効なメールアドレスでも登録できてしまう

## 再現手順
1. `/register` ページにアクセス
2. メールアドレス欄に `invalid-email` と入力
3. 「登録」ボタンをクリック
4. エラーが表示されず、登録が成功してしまう

## 期待される動作
無効なメールアドレス形式の場合、エラーメッセージ
「有効なメールアドレスを入力してください」を表示

## 実際の動作
バリデーションがスキップされ、そのまま登録される

## 環境
- OS: macOS 14.0
- Node.js: v20.10.0
- Browser: Chrome 120

## エラーログ
```
(コンソールエラーなし - バリデーション自体が実行されていない)
```

## 提案される修正方針
`src/utils/validation.ts` の `isValidEmail` 関数を確認し、
正規表現パターンを修正する必要がありそう
```

### 2. add-feature（新機能追加）

#### 推奨フォーマット

```markdown
## 機能概要
[何を実現する機能か]

## ユースケース
[誰が、いつ、どのように使うか]

## 要件
### 必須要件
- [ ] [要件1]
- [ ] [要件2]

### 任意要件
- [ ] [要件3]

## UI/UX仕様（該当する場合）
[画面イメージ、ワイヤーフレーム、または詳細な説明]

## API仕様（該当する場合）
```typescript
// エンドポイント
POST /api/v1/users

// リクエスト
{
  "name": string,
  "email": string
}

// レスポンス
{
  "id": string,
  "name": string,
  "email": string,
  "createdAt": string
}
```

## データモデル（該当する場合）
```typescript
interface User {
  id: string;
  name: string;
  email: string;
  createdAt: Date;
}
```

## 制約条件
- [技術的制約]
- [ビジネス制約]

## 成功基準
- [ ] [基準1]
- [ ] [基準2]
```

#### 実例

```markdown
## 機能概要
ユーザープロフィール画像のアップロード機能を追加

## ユースケース
登録済みユーザーが、自分のプロフィールページから
プロフィール画像をアップロードし、表示できるようにする

## 要件
### 必須要件
- [ ] 画像ファイル選択UI（ドラッグ&ドロップ対応）
- [ ] 画像プレビュー表示
- [ ] 対応形式: JPEG, PNG, WebP
- [ ] 最大サイズ: 5MB
- [ ] 自動リサイズ: 400x400px
- [ ] Cloud Storageへのアップロード

### 任意要件
- [ ] 画像トリミング機能
- [ ] フィルター適用

## UI/UX仕様
- プロフィールページ上部にアバター表示領域
- クリックでファイル選択ダイアログ表示
- アップロード中はローディングスピナー表示
- 成功時にトースト通知

## API仕様
```typescript
// エンドポイント
POST /api/v1/users/:userId/avatar

// リクエスト (multipart/form-data)
{
  "avatar": File
}

// レスポンス
{
  "avatarUrl": string,
  "updatedAt": string
}
```

## データモデル
```typescript
interface User {
  id: string;
  name: string;
  email: string;
  avatarUrl?: string; // 新規追加
  createdAt: Date;
  updatedAt: Date;
}
```

## 制約条件
- Firebase Storageの無料枠を超えないこと
- アップロード時間は3秒以内
- 既存のユーザーデータ移行不要（avatarUrlはnullable）

## 成功基準
- [ ] 画像アップロードが正常に完了する
- [ ] プロフィールページで画像が表示される
- [ ] 5MB以上の画像は拒否される
- [ ] 対応外形式（GIF等）は拒否される
- [ ] ローディング状態が適切に表示される
```

### 3. refactor（リファクタリング）

#### 推奨フォーマット

```markdown
## リファクタリング対象
[対象ファイル・モジュール・機能]

## 現在の問題点
- [問題1]
- [問題2]

## リファクタリング目標
- [改善目標1]
- [改善目標2]

## 提案する変更
[具体的な変更内容]

## 影響範囲
- [影響を受けるファイル]
- [影響を受ける機能]

## 後方互換性
- [ ] 破壊的変更なし
- [ ] 破壊的変更あり → [移行ガイド必要]

## テスト戦略
- [既存テストの実行]
- [新規テストの追加]
```

#### 実例

```markdown
## リファクタリング対象
`src/utils/` 配下のヘルパー関数群

## 現在の問題点
- 関数が1つのファイル（utils.ts）に500行以上集約されている
- 型定義が不明確（any型が多用されている）
- 単体テストが不足している（カバレッジ30%）
- 関数間の依存関係が複雑化している

## リファクタリング目標
- モジュール分割による保守性向上
- 型安全性の確保（any型排除）
- テストカバレッジ80%達成
- 依存関係の明確化

## 提案する変更
1. utils.ts を機能別に分割:
   - `validation.ts` - バリデーション関数
   - `formatting.ts` - フォーマット関数
   - `datetime.ts` - 日時処理関数
   - `string.ts` - 文字列操作関数

2. 全関数に明示的な型定義を追加
3. 各モジュールに対応する単体テストファイルを作成
4. barrel export (`index.ts`) で公開APIを整理

## 影響範囲
- 影響を受けるファイル: 約30ファイル（importパス変更）
- 影響を受ける機能: なし（内部実装のみの変更）

## 後方互換性
- [x] 破壊的変更なし
  - 既存の `import { xxx } from './utils'` は引き続き動作
  - barrel exportで互換性維持

## テスト戦略
- 既存テストを全て実行し、パス確認
- 新規テストを追加してカバレッジ80%達成
- TypeScript strict mode で型エラーゼロを確認
```

### 4. deploy（デプロイ）

#### 推奨フォーマット

```markdown
## デプロイ対象
[環境: staging/production]

## デプロイ内容
- [変更内容のサマリー]

## 事前チェック
- [ ] ビルド成功
- [ ] テスト全パス
- [ ] セキュリティスキャン合格
- [ ] パフォーマンステスト完了

## ロールバックプラン
[問題発生時の対処]

## 監視項目
- [監視するメトリクス]

## 通知先
[デプロイ完了・失敗時の通知先]
```

#### 実例

```markdown
## デプロイ対象
Production環境 (Firebase Hosting + Cloud Functions)

## デプロイ内容
- ユーザープロフィール画像アップロード機能（Issue #15）
- メールバリデーション修正（Issue #12）
- パフォーマンス最適化（Issue #18）

## 事前チェック
- [x] ビルド成功（`npm run build`）
- [x] テスト全パス（`npm test` - 98% coverage）
- [x] セキュリティスキャン合格（npm audit: 0 vulnerabilities）
- [x] パフォーマンステスト完了（Lighthouse score: 95+）
- [x] Staging環境で動作確認完了

## ロールバックプラン
問題発生時は以下を実行:
```bash
# 直前のバージョンにロールバック
firebase hosting:rollback

# Cloud Functionsもロールバック
firebase functions:rollback
```

## 監視項目
デプロイ後30分間、以下を監視:
- エラーレート（目標: < 0.1%）
- レスポンスタイム（目標: < 200ms p95）
- アップロード成功率（目標: > 99%）
- Firebase Storage使用量

## 通知先
- Slack: #deployments チャンネル
- Email: tech-team@example.com
- PagerDuty: Critical errors only
```

### 5. review-pr（PRレビュー）

#### 推奨フォーマット

```markdown
## PR概要
[何を変更したか]

## レビュー観点
### 必須確認項目
- [ ] コードの正確性
- [ ] 型安全性
- [ ] テストカバレッジ
- [ ] セキュリティ

### 推奨確認項目
- [ ] パフォーマンス
- [ ] 保守性
- [ ] ドキュメント

## 特に注目してほしい点
[レビュアーに確認してほしい箇所]

## 懸念事項（あれば）
[不安な点、議論したい点]
```

---

## プロンプトテンプレート集

### 基本テンプレート

#### シンプル版（小規模な変更向け）

```markdown
## 変更内容
[何をするか、1-2文で]

## 理由
[なぜ必要か]

## 成功条件
- [ ] [条件1]
- [ ] [条件2]
```

#### 標準版（通常の開発向け）

```markdown
## 概要
[変更の概要]

## 背景・目的
[なぜこの変更が必要か]

## 要件
### 必須
- [ ] [必須要件1]
- [ ] [必須要件2]

### 任意
- [ ] [任意要件1]

## 実装方針
[どのように実装するか]

## テスト計画
- [ ] [テスト項目1]
- [ ] [テスト項目2]

## 成功基準
[完了の定義]
```

#### 詳細版（大規模変更・アーキテクチャ変更向け）

```markdown
## エグゼクティブサマリー
[経営層・非技術者向けの1段落サマリー]

## 背景
### 現状の課題
[既存システムの問題点]

### なぜ今やるべきか
[ビジネス価値、緊急性]

## 提案内容
### 概要
[何を作るか・変更するか]

### 技術スタック
- [使用する技術・ライブラリ]

### アーキテクチャ図
[システム構成図、データフロー図]

## 詳細要件
### 機能要件
1. [要件1]
2. [要件2]

### 非機能要件
- **パフォーマンス**: [目標値]
- **セキュリティ**: [セキュリティ要件]
- **スケーラビリティ**: [スケール要件]
- **可用性**: [SLA目標]

## 実装計画
### フェーズ1: [内容]
- 期間: [予定]
- 成果物: [何ができるか]

### フェーズ2: [内容]
- 期間: [予定]
- 成果物: [何ができるか]

## リスクと対策
| リスク | 影響度 | 発生確率 | 対策 |
|--------|--------|----------|------|
| [リスク1] | High | Medium | [対策] |
| [リスク2] | Medium | Low | [対策] |

## 成功指標（KPI）
- [指標1]: [現状] → [目標]
- [指標2]: [現状] → [目標]

## テスト戦略
### 単体テスト
[単体テスト方針]

### 統合テスト
[統合テスト方針]

### E2Eテスト
[E2Eテスト方針]

### パフォーマンステスト
[負荷テスト方針]

## ロールアウト計画
1. [ステップ1]
2. [ステップ2]
3. [ステップ3]

## ロールバック計画
[問題発生時の対処]

## 文書化
- [ ] READMEの更新
- [ ] APIドキュメントの更新
- [ ] 運用手順書の作成
```

### 応用テンプレート

#### セキュリティ重視版

```markdown
## セキュリティインパクト分析

### 影響範囲
- [ ] 認証・認可
- [ ] データアクセス
- [ ] 外部API連携
- [ ] ユーザー入力処理

### 脅威モデリング
| 脅威 | 影響 | 対策 |
|------|------|------|
| [脅威1] | [影響] | [対策] |

### セキュリティチェックリスト
- [ ] Input validation実装済み
- [ ] Output encoding実装済み
- [ ] 認証・認可チェック実装済み
- [ ] SQL injection対策済み
- [ ] XSS対策済み
- [ ] CSRF対策済み
- [ ] 機密情報のログ出力なし
- [ ] 安全なパスワードハッシュ化

### コンプライアンス
- [ ] GDPR準拠
- [ ] 個人情報保護法準拠
- [ ] 社内セキュリティポリシー準拠
```

#### パフォーマンス重視版

```markdown
## パフォーマンス目標

### 現状
- レスポンスタイム（p95）: [XXX]ms
- スループット: [XXX] req/s
- メモリ使用量: [XXX] MB

### 目標
- レスポンスタイム（p95）: [XXX]ms
- スループット: [XXX] req/s
- メモリ使用量: [XXX] MB

### 最適化方針
1. [最適化1]
2. [最適化2]

### ベンチマーク計画
```bash
# ベンチマークコマンド
[コマンド]
```

### モニタリング
- [監視項目1]
- [監視項目2]
```

### カスタマイズ例

プロジェクト固有の要件に合わせてテンプレートをカスタマイズ：

```markdown
## [プロジェクト名] Issue テンプレート

### ビジネス価値
**顧客インパクト**: [高/中/低]
**収益インパクト**: [具体的な金額・割合]

### 技術的詳細
[技術仕様]

### [組織固有のセクション]
[カスタム項目]
```

---

## 実践チュートリアル

### 初心者向け：最初のバグ修正

**シナリオ**: ログインボタンが正しく動作しない

**ステップ1: Issue作成**

```bash
gh issue create --title "ログインボタンが反応しない" --body "$(cat <<'EOF'
## バグ内容
ログインページで「ログイン」ボタンをクリックしても反応がない

## 再現手順
1. /login ページにアクセス
2. 正しいメールアドレスとパスワードを入力
3. 「ログイン」ボタンをクリック
4. 何も起こらない

## 期待される動作
ログインが成功し、ダッシュボードにリダイレクトされる

## 実際の動作
ボタンをクリックしても何も起こらない

## 環境
- ブラウザ: Chrome 120
- OS: macOS 14

## エラーログ
コンソールに以下のエラー:
```
Uncaught TypeError: Cannot read property 'handleLogin' of undefined
```
EOF
)"
```

**ステップ2: miyabiで自動修正**

```bash
# Local CodeGen使用
./scripts/local-codegen.sh 5

# または miyabi CLI使用（API key設定済みの場合）
npx miyabi run -i 5 -t fix-bug -m guided -a critical
```

**ステップ3: 結果確認**

- Draft PRが自動作成される
- 修正内容をレビュー
- テストが通ることを確認
- マージ

### 中級者向け：新機能の追加

**シナリオ**: ダークモード機能を追加

**ステップ1: 要件定義Issue作成**

```bash
gh issue create --title "ダークモード機能の実装" --body "$(cat <<'EOF'
## 機能概要
アプリ全体にダークモードを追加し、ユーザーが
ライト/ダークを切り替えられるようにする

## ユースケース
夜間使用時や低光量環境で目の負担を軽減したいユーザーが、
設定画面からダークモードを有効化できる

## 要件
### 必須要件
- [ ] ダークモードON/OFFトグルスイッチ（設定画面）
- [ ] システム設定に追従するオプション
- [ ] 全ページ・全コンポーネントでダークモード対応
- [ ] ユーザー設定をlocalStorageに永続化
- [ ] スムーズなテーマ切り替えアニメーション

### 任意要件
- [ ] カスタムカラーテーマ
- [ ] 時間帯による自動切り替え

## 技術仕様
- CSS Variables使用
- Tailwind Dark Mode機能活用
- Context APIで状態管理

## 成功基準
- [ ] 全ページでダークモード表示が正しい
- [ ] 設定が永続化される
- [ ] パフォーマンス低下なし（Lighthouse 90+維持）
- [ ] アクセシビリティ基準クリア（WCAG 2.1 AA）
EOF
)"
```

**ステップ2: 実装**

```bash
npx miyabi run -i 6 -t add-feature -m auto -a critical --verbose
```

**ステップ3: 品質確認**

生成されたPRで以下を確認：
- [ ] CSS Variablesが正しく定義されている
- [ ] 全コンポーネントがダークモード対応
- [ ] テストが追加されている
- [ ] ドキュメントが更新されている

### 上級者向け：アーキテクチャ改善

**シナリオ**: モノリスからマイクロサービスへの移行

**ステップ1: 提案Issue作成**

```bash
gh issue create --title "認証サービスのマイクロサービス化" --body "$(cat <<'EOF'
## エグゼクティブサマリー
現在のモノリシックアーキテクチャから、認証機能を独立した
マイクロサービスとして分離し、スケーラビリティと保守性を向上させる

## 背景
### 現状の課題
- 認証処理がメインアプリと密結合
- スケールアウトが非効率（全体をスケールする必要）
- デプロイ時に全機能が影響を受ける
- 認証機能の変更がリスク高

### なぜ今やるべきか
- ユーザー数が10万人突破（認証負荷増大）
- コンプライアンス要件で認証ログの分離が必要
- 新規サービス（モバイルアプリ）でも同じ認証を使いたい

## 提案内容
### 概要
認証機能を独立したマイクロサービス（Auth Service）として分離

### 技術スタック
- Runtime: Node.js + Express
- Database: PostgreSQL (認証情報専用)
- Cache: Redis (セッション管理)
- Deploy: Cloud Run (auto-scaling)
- API Gateway: Cloud Endpoints

### アーキテクチャ図
```
┌─────────────────┐
│  Web Frontend   │
└────────┬────────┘
         │
         ▼
┌─────────────────┐      ┌──────────────┐
│   API Gateway   │─────▶│ Auth Service │
└────────┬────────┘      └──────┬───────┘
         │                       │
         │                       ▼
         │              ┌─────────────────┐
         │              │ PostgreSQL      │
         │              │ (auth_db)       │
         │              └─────────────────┘
         │
         ▼
┌─────────────────┐
│  Main Service   │
│  (existing)     │
└─────────────────┘
```

## 詳細要件
### 機能要件
1. ユーザー登録・ログイン・ログアウト
2. JWT トークン発行・検証
3. パスワードリセット
4. 2FA（オプション）
5. OAuth連携（Google, GitHub）

### 非機能要件
- **パフォーマンス**: ログインレスポンス < 200ms (p95)
- **セキュリティ**: SOC 2 Type II準拠
- **スケーラビリティ**: 1,000 req/s まで自動スケール
- **可用性**: 99.9% uptime

## 実装計画
### フェーズ1: Auth Service構築（4週間）
- Auth Service基本実装
- JWT発行・検証機能
- Database migration

### フェーズ2: 統合テスト（2週間）
- E2Eテスト
- 負荷テスト
- セキュリティ監査

### フェーズ3: 段階的ロールアウト（2週間）
- 10% traffic → Auth Service
- 50% traffic → Auth Service
- 100% traffic → Auth Service
- 旧認証機能廃止

## リスクと対策
| リスク | 影響度 | 発生確率 | 対策 |
|--------|--------|----------|------|
| データ移行失敗 | Critical | Medium | Dry-run複数回実施、ロールバック手順確保 |
| パフォーマンス劣化 | High | Low | 事前負荷テスト、段階的ロールアウト |
| ダウンタイム発生 | Critical | Low | Blue-Green Deployment、即時ロールバック可能 |

## 成功指標（KPI）
- ログインレスポンスタイム: 300ms → 150ms
- デプロイ頻度: 月2回 → 週2回（認証機能）
- インシデント率: 現状維持または改善
- 開発速度: 認証関連の変更が50%高速化

## テスト戦略
### 単体テスト
- カバレッジ 90%以上
- 認証ロジックの境界値テスト

### 統合テスト
- API Gateway <-> Auth Service連携
- Main Service <-> Auth Service連携

### E2Eテスト
- ユーザー登録〜ログイン〜ログアウトフロー
- トークンリフレッシュフロー

### パフォーマンステスト
- 1,000 req/s 負荷テスト
- スパイクトラフィック耐性テスト

## ロールアウト計画
1. Staging環境でAuth Service稼働（1週間検証）
2. Production: 10% traffic転送（1日監視）
3. Production: 50% traffic転送（3日監視）
4. Production: 100% traffic転送（1週間監視）
5. 旧認証システム廃止

## ロールバック計画
各段階で問題発生時は即座に前の状態に戻す
- Traffic比率を0%に戻す（< 1分で実施可能）
- データ同期状態の確認
- インシデントレポート作成

## 文書化
- [ ] Auth Service APIドキュメント
- [ ] 運用手順書
- [ ] トラブルシューティングガイド
- [ ] アーキテクチャ決定記録（ADR）
EOF
)"
```

**ステップ2: レビュー・承認**

このレベルの変更は、自動実装前に：
1. Tech Leadレビュー
2. アーキテクチャ委員会承認
3. セキュリティチーム承認

**ステップ3: 段階的実装**

```bash
# フェーズごとに分割してIssue作成
gh issue create --title "Auth Service - Phase 1: 基本実装"
gh issue create --title "Auth Service - Phase 2: 統合テスト"
gh issue create --title "Auth Service - Phase 3: ロールアウト"

# 各フェーズでmiyabi実行
npx miyabi run -i 7 -t add-feature -m safe -a all
```

---

## トラブルシューティング

### よくある問題と解決策

#### 問題1: 品質スコアが80点未満

**症状**:
```
❌ Quality Score: 65/100
- ESLint errors: 5
- TypeScript errors: 2
- Security vulnerabilities: 1 (Medium)
```

**原因**:
- 要件が曖昧で、実装の方向性が定まらない
- コーディング規約が明示されていない
- セキュリティ要件が不足

**解決策**:
1. Issueに明確なコーディング規約を追記
```markdown
## コーディング規約
- ESLint: Airbnb設定準拠
- TypeScript: Strict mode有効
- 全exportに型定義必須
```

2. セキュリティ要件を明示
```markdown
## セキュリティ要件
- ユーザー入力は全てバリデーション
- SQL queryはPrepared Statement使用
- 機密情報のログ出力禁止
```

3. 再実行
```bash
npx miyabi run -i X -t fix-bug -m guided --verbose
```

#### 問題2: 実装が要件を満たさない

**症状**:
生成されたコードが期待と異なる

**原因**:
- 要件の記述が抽象的すぎる
- 期待される成果が明確でない
- 技術的制約が伝わっていない

**解決策**:
1. 具体的な実例を追加
```markdown
## 期待される動作（具体例）

### 入力
```json
{
  "email": "user@example.com",
  "password": "SecurePass123!"
}
```

### 出力（成功時）
```json
{
  "success": true,
  "token": "eyJhbGc...",
  "user": {
    "id": "user_123",
    "email": "user@example.com"
  }
}
```

### 出力（失敗時）
```json
{
  "success": false,
  "error": {
    "code": "INVALID_CREDENTIALS",
    "message": "メールアドレスまたはパスワードが正しくありません"
  }
}
```
```

2. 技術的制約を明示
```markdown
## 技術的制約
- 既存の `UserRepository` インターフェースを使用すること
- bcrypt でパスワードハッシュ化（rounds=10）
- JWT有効期限は24時間
```

#### 問題3: エスカレーションが発生

**症状**:
```
🚨 Escalated to TechLead (Sev.2-High)
Reason: Complex architectural decision required
```

**原因**:
- アーキテクチャ判断が必要な変更
- 既存システムへの影響が大きい
- セキュリティリスクが高い

**解決策**:
1. Issue に設計方針を追記
```markdown
## 設計方針（TechLead承認済み）
- 既存のAuthMiddlewareを拡張する方向で実装
- 新規にAuthServiceを作成せず、既存構造を維持
- データベーススキーマ変更は最小限に
```

2. 再実行時に設計方針を明示
```bash
npx miyabi run -i X -t add-feature -m guided -a critical
```

#### 問題4: テストが失敗する

**症状**:
```
❌ Test Failed: 15/20 passing
```

**原因**:
- テストケースが不明確
- エッジケースが考慮されていない

**解決策**:
1. 詳細なテストケースを追加
```markdown
## テストケース

### 正常系
- [ ] 有効なメール・パスワードでログイン成功
- [ ] トークンが正しく発行される
- [ ] ユーザー情報が正しく返される

### 異常系
- [ ] 無効なメールアドレスでエラー
- [ ] 間違ったパスワードでエラー
- [ ] 存在しないユーザーでエラー
- [ ] 空の入力でバリデーションエラー

### エッジケース
- [ ] 非常に長いパスワード（1000文字）
- [ ] 特殊文字を含むメールアドレス
- [ ] 連続ログイン試行（rate limiting）
```

#### 問題5: パフォーマンスが目標未達

**症状**:
実装後のベンチマークで目標値に届かない

**原因**:
- パフォーマンス要件が明示されていない
- 最適化の観点が不足

**解決策**:
1. 明確なパフォーマンス要件を追加
```markdown
## パフォーマンス要件

### レスポンスタイム
- p50: < 100ms
- p95: < 200ms
- p99: < 500ms

### スループット
- 最低: 500 req/s
- 目標: 1,000 req/s

### リソース
- メモリ: < 512MB
- CPU: < 50% (2 cores)

## 最適化方針
- Database query最適化（index使用）
- Redis caching活用
- 不要なデータ取得を削減
```

---

## アンチパターン

### ❌ 避けるべき曖昧な指示

#### アンチパターン1: 「何とかして」系

**悪い例**:
```markdown
ログイン機能をもっと良くして
```

**問題点**:
- 「良くする」が何を意味するか不明
- 現状の問題点が分からない
- 成功の定義がない

**良い例**:
```markdown
## 現状の問題
ログインに平均3秒かかり、ユーザーから遅いとの苦情

## 改善目標
ログインレスポンスタイムを1秒以内に短縮

## 提案する改善策
- Database queryの最適化（index追加）
- JWT生成処理の並列化
- 不要なデータ取得の削除
```

#### アンチパターン2: 「適当に」系

**悪い例**:
```markdown
適当にエラーハンドリング追加して
```

**問題点**:
- どのエラーをハンドリングすべきか不明
- エラー時の挙動が未定義
- ユーザー体験への配慮がない

**良い例**:
```markdown
## エラーハンドリング要件

### 対象エラー
1. ネットワークエラー
2. バリデーションエラー
3. 認証エラー
4. サーバーエラー（500系）

### エラーごとの挙動
| エラー種別 | ユーザー表示 | ログ | リトライ |
|-----------|-------------|------|---------|
| ネットワーク | 「接続できません」 | warn | 3回 |
| バリデーション | 具体的なエラー内容 | info | なし |
| 認証 | 「ログインしてください」 | warn | なし |
| サーバー | 「エラーが発生しました」 | error | 1回 |

### UI仕様
- エラーメッセージはトースト表示
- 自動で5秒後に消える
- 手動で閉じることも可能
```

#### アンチパターン3: 技術指定のみ

**悪い例**:
```markdown
React Query使ってデータフェッチング実装して
```

**問題点**:
- 何のデータを取得するのか不明
- いつ・どこで使うのか不明
- ビジネス要件が不在

**良い例**:
```markdown
## 機能概要
ユーザー一覧画面で、ユーザーデータをサーバーから取得して表示

## 技術要件
- React Query使用（キャッシュ・リトライ機能活用）
- ページネーション対応（20件/ページ）
- 検索・フィルタリング機能

## データ仕様
```typescript
interface User {
  id: string;
  name: string;
  email: string;
  role: 'admin' | 'user';
  createdAt: string;
}

// APIエンドポイント
GET /api/v1/users?page=1&limit=20&search=keyword
```

## UI仕様
- ローディング中はスケルトンスクリーン表示
- エラー時はリトライボタン表示
- データ更新時は自動再取得
```

### ❌ 過度に詳細すぎる指示

#### アンチパターン4: 実装コードを書く

**悪い例**:
```markdown
以下のコードをそのまま実装して：

```typescript
function login(email: string, password: string) {
  const user = db.users.find(u => u.email === email);
  if (!user) throw new Error('User not found');
  const valid = bcrypt.compare(password, user.passwordHash);
  if (!valid) throw new Error('Invalid password');
  const token = jwt.sign({ userId: user.id }, SECRET, { expiresIn: '24h' });
  return { token, user };
}
```
```

**問題点**:
- AIの判断余地がない
- ベストプラクティスが適用されない
- エラーハンドリングが不十分
- テストが考慮されていない

**良い例**:
```markdown
## ログイン機能実装

### 要件
- メールアドレスとパスワードで認証
- 成功時はJWTトークンを返す
- 失敗時は適切なエラーを返す

### セキュリティ要件
- パスワードはbcryptでハッシュ化済み
- JWT有効期限は24時間
- 連続ログイン失敗でrate limiting

### エラーハンドリング
- ユーザー不在: 「認証情報が正しくありません」
- パスワード不一致: 「認証情報が正しくありません」
  （※セキュリティのため、どちらか特定させない）
- Rate limit超過: 「しばらく待ってから再試行してください」

### テスト要件
- 正常系・異常系・エッジケースを網羅
- カバレッジ90%以上
```

### ❌ コンテキスト不足の指示

#### アンチパターン5: 背景説明なし

**悪い例**:
```markdown
ユーザーテーブルに `lastLoginAt` カラム追加
```

**問題点**:
- なぜ必要か分からない
- どう使われるか不明
- 他への影響が予測できない

**良い例**:
```markdown
## 背景
ユーザーのアクティビティを追跡し、長期間ログインしていない
ユーザーに再エンゲージメントメールを送信したい

## 変更内容
ユーザーテーブルに最終ログイン日時を記録する

### Database変更
```sql
ALTER TABLE users
ADD COLUMN last_login_at TIMESTAMP NULL;

-- 既存ユーザーは現在時刻で初期化
UPDATE users
SET last_login_at = NOW()
WHERE last_login_at IS NULL;
```

### アプリケーション変更
- ログイン成功時に `lastLoginAt` を更新
- ユーザー一覧APIで `lastLoginAt` を含める

### 活用方法
- 30日間ログインなしユーザーを抽出
- 再エンゲージメントメール送信（別Issue）

### 移行計画
1. カラム追加（NULL許可）
2. 既存データを現在時刻で初期化
3. アプリケーションコード更新・デプロイ
4. 動作確認後、NOT NULL制約追加（任意）
```

---

## まとめ

### 効率的な指示の5原則

1. **明確性**: 曖昧な表現を避け、具体的に記述
2. **完全性**: 必要な情報を漏れなく提供
3. **実例**: 期待される動作を具体例で示す
4. **制約**: 技術的・ビジネス的制約を明示
5. **検証可能性**: 成功基準を定量的に定義

### チェックリスト

Issueを作成する前に、以下を確認：

- [ ] 何を（What）実現したいか明確か
- [ ] なぜ（Why）必要か説明されているか
- [ ] どのように（How）実装するか方針があるか
- [ ] 成功基準（Done）が定義されているか
- [ ] テスト方法が明確か
- [ ] セキュリティ・パフォーマンス要件が考慮されているか

### さらなる学習

- `prompts/miyabi-optimizer.md` - CLIコマンドの最適化
- `.claude/README.md` - Agent仕様の詳細
- 実際のPR履歴 - 成功例を参考に

---

🌸 **Miyabi** - Beauty in Autonomous Development

明確な指示が、美しい自律的開発を実現します。

🤖 Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>
